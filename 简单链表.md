<h1>关于链表的题目的感想</h1>
好吧，其实本来这周的笔记应该是继续数据库的相关内容的，奈何恰逢考试周+各种活动，实在是抽不出空，只好写一遍自己完成链表的题目的感想了，记录一下写题目的心路历程。如果这周能抽得出空，会继续更新sql（好吧真的好忙啊呜呜呜）题目来源第十八周OJ附加题，主要考察链表。<br>
题目大意
<img src="https://github.com/SaltyFishy/-/blob/main/%E9%A2%98%E7%9B%AE1.jpg" alt="">
<img src="https://github.com/SaltyFishy/-/blob/main/%E9%A2%98%E7%9B%AE2.jpg" alt="">
<img src="https://github.com/SaltyFishy/-/blob/main/%E9%A2%98%E7%9B%AE3.jpg" alt="">
<img src="https://github.com/SaltyFishy/-/blob/main/%E8%BE%93%E5%85%A5.jpg" alt="">
<img src="https://github.com/SaltyFishy/-/blob/main/sample.jpg" alt="">

<h2>题目分析</h2>
昂，其实题目的要求也不是很难理解，就是根据姓名首字母形成26个链表，这26个链表组成一个通讯录。<br>
下面我们逐个解决题目的问题：
<ol>
<li>Input函数</li>
<li>operator+=</li>
<li>operator+</li>
<li>operator()</li>
<li>Print函数</li>
</ol>
<h3>Input函数</h3>
Input函数前面其实没什么好说的，但是注意个容易出bug的地方<br>
记得不能用Info构造函数的方式，一定要用动态分配内存，否则存储在stack区的数据会随着循环而丢失，同时为了能够利用指针给Info赋值，我们使用了了friend关键字使通讯录类跟联系人类形成朋友关系。（尽管他们本身实际上不应该是朋友，只是懒得写set、get函数而已）<br>
<img src="https://github.com/SaltyFishy/-/blob/main/friend.jpg" alt="">
有26个链表，插入哪一个链表呢？我们只需要找到姓名首字母并减去'A'字符，就呢能根据一一对应关系找到对应的位置插入链表了。
<img src="" alt="">
<h3>operator+=</h3>
添加联系人有两种情况：
<ol>
<li>要添加的新联系人在原有通讯录中已存在</li>
<li>新联系人在原通讯录中不存在</li>
</ol>
最简单的想法就是直接分两类，先查找是否存在，存在修改号码，不存在则采用头插法插入。
<img src="https://github.com/SaltyFishy/-/blob/main/operator%2B%3D.jpg" alt="">
<h3>operator+</h3>
+的操作对象是两个通讯录组成的集合，每个通讯录下都有26个链表，在这里的加法的定义实质上就是两个链表的加法的定义，对每个链表逐个相加即可。只是这里记得要多声明一个指针，原因是避免可能出现的指针丢失。
<img src="https://github.com/SaltyFishy/-/blob/main/%E6%8C%87%E9%92%88%E8%A7%A3%E9%87%8A.jpg" alt="">
<img src="https://github.com/SaltyFishy/-/blob/main/operator%2B.jpg" alt="">
<h3>operator()</h3>
直接定位即可。。。
<img src="https://github.com/SaltyFishy/-/blob/main/operator%EF%BC%88%EF%BC%89.jpg" alt="">
<h3>Print函数</h3>
依次遍历26个链表即可。
<img src="https://github.com/SaltyFishy/-/blob/main/Print%E5%87%BD%E6%95%B0.jpg" alt="">
<h2>实现代码</h2>
```C++
#include <iostream>
using namespace std;
const int hmax = 26;
class Info { //联系人，用一个链表结点表示
	string name; //姓名
	int phoneNo; //电话
public:
	friend class PhoneBook;                       //为了方便、同时也很自然地，通讯录理应能访问（尽管不是主动）到联系人的信息
	Info* next;  //指向下一个结点
	Info(string tn = "no name", int pno = 0)
	{
		name = tn;
		phoneNo = pno;
		next = NULL;
	}
	void Print()
	{
		cout << name << "--" << phoneNo << endl;
	}
	//属性的get和set方法....自行定义
};
class PhoneBook {//组链表方式实现通讯录
	//....自行增加一些操作
	//提示：把插入和查找先写成内部函数，再被运算符重载调用，会更方便
public:
	Info Table[hmax];	//链表头结点数组，对应26个大写字母
	//以下定义五个操作：输入Input、打印Print、插入、合并、查找
	//具体操作看前面说明
	void Input();
	void Print();
	Info* operator()(string n);
	PhoneBook& operator+=(Info& info);
	PhoneBook& operator+(PhoneBook& book);
};
//...PhoneBook类成员函数，类外实现，自行编写
void PhoneBook::Input() {            //Input函数，实现第一个通讯录的生成
	int n;
	cin >> n;
	string na;
	int num;
	while (n--) {
		cin >> na >> num;
		Info* p1;                 //注意！这里一定要调用堆内存，因为如果是利用Info的构造函数，生成的Info只在一个循环内具有生命周期
		p1 = new Info;
		p1->name = na;
		p1->phoneNo = num;
		string::iterator i = na.begin();     //利用迭代器找到第一个字符
		p1->next = Table[*i - 'A'].next;           //简单的指针变换
		Table[*i - 'A'].next = p1;
	}
}
PhoneBook& PhoneBook::operator+=(Info& info) {      //实现添加联系人
	Info* p;                             
	for (int i = 0; i < 26; i++) {
		p = Table[i].next;
		while (p) {                                 //指针非空
			if (p->name == info.name) {            //若有同名联系人，则只修改号码
				p->phoneNo = info.phoneNo;
				return *this;
			}
			else {
				p = p->next;                        //顺延链表
			}
		}
	}
	string::iterator i = info.name.begin();         //利用迭代器寻找第一个字符
	p = Table[*i - 'A'].next;                       //如果该联系人不存在，则利用头插法插入链表
	Table[*i - 'A'].next = &info;
	info.next = p;
	return *this;
}
void PhoneBook::Print() {
	char s = 'A';                                  //仅为了表示链表头
	for (int i = 0; i < 26; i++) {                 //26个链表逐个展示
		Info* p = Table[i].next;
		if (p) {
			cout << s << "--" << p->name << "." << p->phoneNo << "--";
			p = p->next;
			while (p) {
				cout << p->name << "." << p->phoneNo << "--";
				p = p->next;
			}
			cout << endl;
		}
		s++;
	}
}
PhoneBook& PhoneBook::operator+(PhoneBook& book) {
	Info* p, * p2;
	for (int i = 0; i < 26; i++) {
		if (book.Table[i].next) {             //若某个大写字母下的链表存在
			p = book.Table[i].next;
			p2 = book.Table[i].next->next;     //因为添加联系人时修改了原有的联系人指向的对象，为了避免丢失该指针，要多用一个指针保存该指针
			while (p) {
				*this += (*p);                //如果第二个通讯录中有人还在链表中，则加入
				p = p2;                       //继续遍历链表
				if (p2) {                     //避免p2为空时无法修改p2 = p2->next
					p2 = p2->next;
				}
			}
		}
	}
	return *this;
}
Info* PhoneBook::operator()(string n) {                //搜多
	string::iterator i = n.begin();
	while (Table[*i - 'A'].next) {
		if (n == Table[*i - 'A'].next->name) {                //找到则返回地址
			return Table[*i - 'A'].next;
		}
		else {                                               //未找到则继续链表的遍历
			Table[*i - 'A'].next = (*Table[*i - 'A'].next).next;
		}
	}
	return NULL;
}
//----主函数----
int main()
{
	string tname;
	int i, tno;
	Info* p;
	PhoneBook pb;
	pb.Input(); //接收输入数据，初始化第一个通讯录
	//两次姓名查找
	for (i = 0; i < 2; i++)
	{
		cin >> tname;
		p = pb(tname); //调用()运算符，实现查找
		if (p)	p->Print(); //查找成功，输出联系人信息
		else cout << "查找失败" << endl; //查找失败，输出提示信息
	}
	//一次插入
	cin >> tname >> tno;
	Info temp(tname, tno);
	pb += temp; //调用+=运算符，实现插入新联系人
	//通讯录合并
	PhoneBook pc;
	pc.Input(); //初始化第二个通讯录
	pb = pb + pc; //调用+运算符，实现合并
	pb.Print(); //输出所有操作后的通讯录
	return 0;
}
```


